#include "Ogre3DDisplayFactory.h"
/**
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 **/

/**
 * @file   Ogre3DDisplayFactory.ih
 * @author Anis Benyoub
 * @date   mercredi 14 juin 2012
 *
 * @brief
 *
 * Implementation of inline methods defined in Ogre3DDisplayFactory.h
 *
 * This file is part of the DGtal library.
 */

///////////////////////////////////////////////////////////////////////////////
// Implementation of inline methods                                          //


///////////////////////////////////////////////////////////////////////////////
// Implementation of inline functions and external operators                 //



// ArithmeticalDSS
template <typename TIterator, typename TInteger, int connectivity>
inline
void DGtal::Ogre3DDisplayFactory::draw ( ViewerOgre3D & viewer,
    const DGtal::ArithmeticalDSS3d<TIterator, TInteger, connectivity> & a )
{

  // None as paving drawing
}


// DigitalSetBySTLSet
template<typename Domain>
inline
void DGtal::Ogre3DDisplayFactory::draw ( ViewerOgre3D & viewer,
    const DGtal::DigitalSetBySTLSet<Domain> & s )
{


  typedef typename Domain::Point Point;
  typedef typename Domain::Point::Component Component;
  typedef typename std::set<Point>::const_iterator ConstIterator;

  ASSERT ( Domain::Space::dimension == 3 );

  DGtalNode * theDGtalSetNode = new DGtalNode ( viewer.getSceneMgr() );
  Ogre::SceneNode * theNode = viewer.getANode();
  Representation * theVirtualRepresentation = new Representation ( viewer.getSceneMgr(), theNode, theNode->getName() );

  for ( ConstIterator it = s.begin(); it != s.end(); ++it )
    {
      Representation * newPoint = viewer.addVoxel ( NumberTraits<Component>::castToInt64_t ( ( *it ) [0] ),
                                  NumberTraits<Component>::castToInt64_t ( ( *it ) [1] ),
                                  NumberTraits<Component>::castToInt64_t ( ( *it ) [2] ),
                                  theNode->createChildSceneNode() );


      DGtalNode * newDGtalNode = new DGtalNode ( viewer.getSceneMgr() );
      newDGtalNode->setRepresentation ( newPoint );

      typedef typename Domain::Point Point;
      newPoint->setAttachedParent ( newDGtalNode );
      theDGtalSetNode->addSon ( newDGtalNode );
      newDGtalNode->setFather ( theDGtalSetNode );
      newDGtalNode->setName ( newPoint->getEntityName() );
      viewer.addToList ( newDGtalNode );
      TDrawable<Point > * aPoint = new TDrawable<Point > ( ( *it ) ) ;
      DrawableWithOgre * aDrawableObject = ( DrawableWithOgre * ) aPoint;
      newDGtalNode->setDGtalObject ( aDrawableObject );

    }

  theDGtalSetNode->setName ( theVirtualRepresentation->getName() );

  theDGtalSetNode->setRepresentation ( theVirtualRepresentation );
  theDGtalSetNode->setFather ( viewer.getRootDGtalNode() );
  viewer.getRootDGtalNode()->addSon ( theDGtalSetNode );
  viewer.addToList ( theDGtalSetNode );

  TDrawable<DigitalSetBySTLSet<Domain> >  * aSet = new TDrawable<DigitalSetBySTLSet<Domain> > ( s );
  DrawableWithOgre * theDrawableObject = ( DrawableWithOgre * ) aSet;
  theDGtalSetNode->setDGtalObject ( theDrawableObject );

}

//DigitalSetBySTLVector
template<typename Domain>
inline
void DGtal::Ogre3DDisplayFactory::draw ( ViewerOgre3D & viewer,
    const DGtal::DigitalSetBySTLVector<Domain> & s )
{
  typedef typename Domain::Point Point;
  typedef typename Domain::Point::Component Component;
  typedef typename std::vector<Point>::const_iterator ConstIterator;

  ASSERT ( Domain::Space::dimension == 3 );

  DGtalNode * theDGtalSetNode = new DGtalNode ( viewer.getSceneMgr() );
  Ogre::SceneNode * theNode = viewer.getANode();
  Representation * theVirtualRepresentation = new Representation ( viewer.getSceneMgr(), theNode, theNode->getName() );





  for ( ConstIterator it = s.begin(); it != s.end(); ++it )
    {
      Representation * newPoint = viewer.addVoxel ( NumberTraits<Component>::castToInt64_t ( ( *it ) [0] ),
                                  NumberTraits<Component>::castToInt64_t ( ( *it ) [1] ),
                                  NumberTraits<Component>::castToInt64_t ( ( *it ) [2] ),
                                  theNode->createChildSceneNode() );


      DGtalNode * newDGtalNode = new DGtalNode ( viewer.getSceneMgr() );
      newDGtalNode->setRepresentation ( newPoint );

      typedef typename Domain::Point Point;
      newPoint->setAttachedParent ( newDGtalNode );
      theDGtalSetNode->addSon ( newDGtalNode );
      newDGtalNode->setFather ( theDGtalSetNode );
      newDGtalNode->setName ( newPoint->getEntityName() );
      viewer.addToList ( newDGtalNode );
      TDrawable<Point > * aPoint = new TDrawable<Point > ( ( *it ) ) ;
      DrawableWithOgre * aDrawableObject = ( DrawableWithOgre * ) aPoint;
      newDGtalNode->setDGtalObject ( aDrawableObject );

    }

  theDGtalSetNode->setName ( theVirtualRepresentation->getName() );

  theDGtalSetNode->setRepresentation ( theVirtualRepresentation );
  theDGtalSetNode->setFather ( viewer.getRootDGtalNode() );
  viewer.getRootDGtalNode()->addSon ( theDGtalSetNode );
  viewer.addToList ( theDGtalSetNode );

  TDrawable<DigitalSetBySTLSet<Domain> >  * aSet = new TDrawable<DigitalSetBySTLSet<Domain> > ( s );
  DrawableWithOgre * theDrawableObject = ( DrawableWithOgre * ) aSet;
  theDGtalSetNode->setDGtalObject ( theDrawableObject );
}




template<typename TSpace>
inline
void DGtal::Ogre3DDisplayFactory::draw ( ViewerOgre3D &viewer,
    const DGtal::HyperRectDomain<TSpace> & h )
{
  typedef typename TSpace::Integer Integer;

  ASSERT ( TSpace::dimension == 3 );

  DGtalNode * theDGtalSetNode = new DGtalNode ( viewer.getSceneMgr() );
  Ogre::SceneNode * theNode = viewer.getANode();
  Representation * theVirtualRepresentation = new Representation ( viewer.getSceneMgr(), theNode, theNode->getName() );


  if ( TSpace::dimension == 3 )
    {
      // Face XY
      for ( int64_t z = NumberTraits<Integer>::castToInt64_t ( h.myLowerBound[2] );
            z <=  NumberTraits<Integer>::castToInt64_t ( h.myUpperBound[2] ); z++ )
        {
          for ( int64_t x = NumberTraits<Integer>::castToInt64_t ( h.myLowerBound[0] );
                x <=  NumberTraits<Integer>::castToInt64_t ( h.myUpperBound[0] ); x++ )
            {

              for ( int64_t y =  NumberTraits<Integer>::castToInt64_t ( h.myLowerBound[1] );
                    y <=  NumberTraits<Integer>::castToInt64_t ( h.myUpperBound[1] ); y++ )
                {
                  Representation * newPoint = viewer.addVoxel ( x, y, z, theNode->createChildSceneNode() );

                  DGtalNode * newDGtalNode = new DGtalNode ( viewer.getSceneMgr() );
                  newDGtalNode->setRepresentation ( newPoint );

                  typedef typename TSpace::Point Point;
                  newPoint->setAttachedParent ( newDGtalNode );
                  theDGtalSetNode->addSon ( newDGtalNode );
                  newDGtalNode->setFather ( theDGtalSetNode );
                  newDGtalNode->setName ( newPoint->getEntityName() );
                  viewer.addToList ( newDGtalNode );
                  TDrawable<Point > * aPoint = new TDrawable<Point > ( ( Point ( x, y, z ) ) ) ;
                  DrawableWithOgre * aDrawableObject = ( DrawableWithOgre * ) aPoint;
                  newDGtalNode->setDGtalObject ( aDrawableObject );


                }
            }
        }

      theDGtalSetNode->setName ( theVirtualRepresentation->getName() );

      theDGtalSetNode->setRepresentation ( theVirtualRepresentation );
      theDGtalSetNode->setFather ( viewer.getRootDGtalNode() );
      viewer.getRootDGtalNode()->addSon ( theDGtalSetNode );
      viewer.addToList ( theDGtalSetNode );

      TDrawable<HyperRectDomain<TSpace> >  * aSet = new TDrawable<HyperRectDomain<TSpace> > ( h );
      DrawableWithOgre * theDrawableObject = ( DrawableWithOgre * ) aSet;
      theDGtalSetNode->setDGtalObject ( theDrawableObject );
    }
}




// KhalimskyCell
template < Dimension dim, typename TInteger >
inline
void DGtal::Ogre3DDisplayFactory::draw ( ViewerOgre3D & display,
    const DGtal::KhalimskyCell<dim, TInteger> & k )
{
  ASSERT ( dim == 3 );

// used to display surfels located at a same position.
  double factorVolSurfel = 1.0;
  bool basicMode = false;
  double x = ( double ) ( NumberTraits<TInteger>::castToInt64_t ( k.myCoordinates[0] ) >> 1 );
  double y = ( double ) ( NumberTraits<TInteger>::castToInt64_t ( k.myCoordinates[1] ) >> 1 ) ;
  double z = ( double ) ( NumberTraits<TInteger>::castToInt64_t ( k.myCoordinates[2] ) >> 1 );

  bool xodd = ( NumberTraits<TInteger>::castToInt64_t ( k.myCoordinates[ 0 ] ) & 1 );
  bool yodd = ( NumberTraits<TInteger>::castToInt64_t ( k.myCoordinates[ 1 ] ) & 1 );
  bool zodd = ( NumberTraits<TInteger>::castToInt64_t ( k.myCoordinates[ 2 ] ) & 1 );


  unsigned int spaceDim = ( xodd ? 1 : 0 ) + ( yodd ? 1 : 0 ) + ( zodd ? 1 : 0 );

  switch ( spaceDim )
    {

      case 0:
        display.addKSPointel ( x - 0.5, y - 0.5, z - 0.5, NULL );
        break;

      case 1:
        display.addKSLinel ( x - 0.5, y - 0.5, z - 0.5, NULL );
        break;

      case 2:
        display.addKSSurfel ( x, y, z, NULL );
        break;

      case 3:
        display.addKSVoxel ( ( int ) x, ( int ) y, ( int ) z, NULL );
        break;
    }
}



//Object
template <typename TDigitalTopology, typename TDigitalSet>
inline
void DGtal::Ogre3DDisplayFactory::draw ( ViewerOgre3D &viewer,
    const DGtal::Object< TDigitalTopology, TDigitalSet > & set )
{


}


//PointVector
template<Dimension dim, typename TComponent>
inline
void DGtal::Ogre3DDisplayFactory::draw ( ViewerOgre3D & viewer,
    const PointVector<dim, TComponent> & p )
{

  ASSERT ( dim == 3 );
  DGtalNode * newDGtalNode = new DGtalNode ( viewer.getSceneMgr() );

  Ogre::SceneNode * theNode = viewer.getANode();
  Representation * newPoint = viewer.addVoxel ( NumberTraits<TComponent>::castToDouble ( p.myArray[0] ),
                              NumberTraits<TComponent>::castToDouble ( p.myArray[1] ),
                              NumberTraits<TComponent>::castToDouble ( p.myArray[2] ), theNode );

  ASSERT ( newPoint );
  ASSERT ( theNode );

  newDGtalNode->setName ( newPoint->getName() );
  newDGtalNode->setRepresentation ( newPoint );
  newPoint->setAttachedParent ( newDGtalNode );
  newDGtalNode->setFather ( viewer.getRootDGtalNode() );
  viewer.addToList ( newDGtalNode );
  TDrawable<PointVector<dim, TComponent> > *  aPoint = new TDrawable<PointVector<dim, TComponent> > ( p );

  ASSERT ( aPoint );
  DrawableWithOgre * aDrawableObject = ( DrawableWithOgre * ) aPoint;
  newDGtalNode->setDGtalObject ( aDrawableObject );
  viewer.getRootDGtalNode()->addSon ( newDGtalNode );

}




// SignedKhalimskyCell
template< Dimension dim, typename TInteger >
inline
void DGtal::Ogre3DDisplayFactory::draw ( ViewerOgre3D & display,
    const DGtal::SignedKhalimskyCell<dim, TInteger> & sk )
{

  ASSERT ( dim == 3 );

  float x = ( float )
            ( NumberTraits<TInteger>::castToInt64_t ( sk.myCoordinates[0] ) >> 1 );
  float y = ( float )
            ( NumberTraits<TInteger>::castToInt64_t ( sk.myCoordinates[1] ) >> 1 );
  float z = ( float )
            ( NumberTraits<TInteger>::castToInt64_t ( sk.myCoordinates[2] ) >> 1 );

  bool xodd = ( sk.myCoordinates[ 0 ] & 1 );
  bool yodd = ( sk.myCoordinates[ 1 ] & 1 );
  bool zodd = ( sk.myCoordinates[ 2 ] & 1 );


  unsigned int spaceDim = ( xodd ? 1 : 0 ) + ( yodd ? 1 : 0 ) + ( zodd ? 1 : 0 );
// pointel

  switch ( spaceDim )
    {

      case 0:
        display.addKSPointel ( x - 0.5, y - 0.5, z - 0.5, NULL );
        break;

      case 1:
        display.addKSLinel ( x - 0.5, y - 0.5, z - 0.5, NULL );
        break;

      case 2:

        display.addKSSurfel ( x, y, z, NULL );
        break;

      case 3:
        display.addKSVoxel ( ( int ) x, ( int ) y, ( int ) z, NULL );
        break;
    }
}

// SignedKhalimskyCell






/*
inline
void DGtal::Ogre3DDisplayFactory::draw( ViewerOgre3D & display,
        const DGtal::SetMode3D & sm3d )
{
  display.myModes[ sm3d.myClassname ] = sm3d.myMode;
}

inline
void DGtal::Ogre3DDisplayFactory::draw( ViewerOgre3D & display,
        const DGtal::CustomStyle3D & cs3d )
{
  display.myStyles[ cs3d.myClassname ] = cs3d.myStyle;
}

inline
void DGtal::Ogre3DDisplayFactory::draw( ViewerOgre3D & display, const DGtal::CustomColors3D & cc3d )
{
  display.setFillColor(cc3d.myFillColor);
  display.setLineColor(cc3d.myPenColor);
}
*/

inline
void DGtal::Ogre3DDisplayFactory::draw ( ViewerOgre3D & display, const DGtal::ClippingPlane & cp )
{
  display.addClippingPlane ( cp.myA, cp.myB, cp.myC, cp.myD );
}

inline
void DGtal::Ogre3DDisplayFactory::draw ( ViewerOgre3D & display,
    const DGtal::CameraPosition & cp )
{
  display.setCameraPosition ( Ogre::Vector3 ( cp.eyex, cp.eyey, cp.eyez ) );
}

inline
void DGtal::Ogre3DDisplayFactory::draw ( ViewerOgre3D & display,
    const DGtal::CameraDirection & cd )
{
  display.setCameraDirection ( Ogre::Vector3 ( cd.dirx, cd.diry, cd.dirz ) );
}

inline
void DGtal::Ogre3DDisplayFactory::draw ( ViewerOgre3D & display, const DGtal::CameraUpVector & cuv )
{

  display.setCameraUpVector ( Ogre::Vector3 ( cuv.upx, cuv.upy, cuv.upz ) );
}

inline
void DGtal::Ogre3DDisplayFactory::draw ( ViewerOgre3D & display,
    const DGtal::CameraZNearFar & cz )
{
  display.setNearFar ( cz.ZNear, cz.ZFar );
}


