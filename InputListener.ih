/**
* This program is free software: you can redistribute it and/or modify
* it under the terms of the GNU Lesser General Public License as
* published by the Free Software Foundation, either version 3 of the
* License, or (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this program. If not, see <http://www.gnu.org/licenses/>.
*
**/

/**
* @file InputListener.cpp
* @author Anis Benyoub (\c anis.benyoub@insa-lyon.fr )
* Liris CNRS
*
* @date 2012/06/10
*
* Implementation of methods defined in InputListener.h
*
* This file is part of the DGtal library.
*/

///////////////////////////////////////////////////////////////////////////////
#include "InputListener.h"
#include <iostream>
///////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////
// class InputListener
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// Standard services - public :



/**
 * Constructor.
 */
InputListener::InputListener ( Ogre::RenderWindow * aWindow, ViewerOgre3D * aViewer, Ogre::Camera * aCamera, Ogre::SceneManager * aSceneManager ) :
    myWindow ( aWindow ), myViewer ( aViewer )

{
  // Camera Intiate
  myCamera = aCamera;
  myCameraMan = new CameraMan ( myCamera );


  //Window initiate
  OIS::ParamList pl;
  unsigned long windowHnd = 0;
  std::stringstream windowHndStr;
  aWindow->getCustomAttribute ( "WINDOW", &windowHnd );
  windowHndStr << windowHnd;
  pl.insert ( OIS::ParamList::value_type ( "WINDOW", Ogre::StringConverter::toString ( aWindow ) ) );


  // Input initate
  myInputManager = OIS::InputManager::createInputSystem ( windowHnd );
  myKeyboard = static_cast<OIS::Keyboard*> ( myInputManager->createInputObject ( OIS::OISKeyboard, true ) );
  myMouse = static_cast<OIS::Mouse*> ( myInputManager->createInputObject ( OIS::OISMouse, true ) );
  myKeyboard->setEventCallback ( this );
  myMouse->setEventCallback ( this );




  // End flag initate
  myShutdown = false;

  // Other Flags initate
  myMouseRightClicked = false;
  myMouseLeftClicked = false ;


  // Cursor initating
  myMouseCursor = new MouseCursor();
  myMouseCursor->setImage ( "cursor.png" );
  myMouseCursor->setVisible ( true );
  myMouseCursor->setWindowDimensions ( myWindow->getWidth(), myWindow->getHeight() );
  const OIS::MouseState &ms = myMouse->getMouseState();
  ms.width = myWindow->getWidth();
  ms.height = myWindow->getHeight();



  // Other initating
  myIsInShiftMode = false;
  mySceneMgr = aSceneManager;
}



/**
* Destructor.
*/
InputListener::~InputListener()
{
  myInputManager->destroyInputObject ( myKeyboard );
  myInputManager->destroyInputObject ( myMouse );
  delete myCameraMan;
  OIS::InputManager::destroyInputSystem ( myInputManager );
}



/**
  * the rendering method
  */
bool InputListener::frameRenderingQueued ( const Ogre::FrameEvent & evt )
{
  if ( myMouse )
    myMouse->capture();

  if ( myKeyboard )
    myKeyboard->capture();

  if ( myWindow->isClosed() || myShutdown )
    return false;

  myCameraMan->render ( evt );

  return true;
}



/**
  * Method that initiate the inputManager (First frame)
  */
bool InputListener::frameStarted ( const Ogre::FrameEvent & evt )
{
  return true;
}


/**
  * The last frame
  */
bool InputListener::frameEnded ( const Ogre::FrameEvent &evt )
{
  return true;
}



/**
  * Handles a key press
  */
bool InputListener::keyPressed ( const OIS::KeyEvent & evt )
{
  switch ( evt.key )
    {

      case OIS::KC_ESCAPE:
        myShutdown = true;
        return false;
        break;


      case::OIS::KC_O:

        if ( myViewer->isInManupulatingMode() )
          {
            myViewer->abortManupulating();
          }

        break;

      case::OIS::KC_SUBTRACT:

        if ( myViewer->isInManupulatingMode() )
          {
            myViewer->newManipulatingValue ( -1 );
          }

        break;

      case::OIS::KC_ADD:

        if ( myViewer->isInManupulatingMode() )
          {
            myViewer->newManipulatingValue ( 1 );
          }

        break;

      case OIS::KC_P:

        myViewer->changeAxisVisibility();
        break;

      default:
        break;

    }

  myCameraMan->handleKeyPress ( evt );

  return true;

}



/**
  * Handles a mouse press
  */
bool InputListener::mousePressed ( const OIS::MouseEvent &arg, OIS::MouseButtonID id )
{
  if ( !myIsInShiftMode && ( id == OIS::MB_Left ) )
    {
      myViewer->lookForIt ( myMouse->getMouseState().X.abs, myMouse->getMouseState().Y.abs, myWindow->getHeight(), myWindow->getWidth() );
    }

  if ( id == OIS::MB_Left )
    {
      myMouseLeftClicked = true;
    }

  if ( id == OIS::MB_Right )
    {
      myMouseRightClicked = true;
    }
}



/**
  * Handles a mouse release
  */
bool InputListener::mouseReleased ( const OIS::MouseEvent &e, OIS::MouseButtonID id )
{
  if ( id == OIS::MB_Left )
    {
      myMouseLeftClicked = false;
    }

  if ( id == OIS::MB_Right )
    {
      myMouseRightClicked = false;
    }

  return true;
}



/**
  * Handles a key release
  */
bool InputListener::keyReleased ( const OIS::KeyEvent &e )
{

  switch ( e.key )
    {

      case OIS::KC_CAPITAL:
        myIsInShiftMode = !myIsInShiftMode;
        myMouseCursor->setVisible ( !myIsInShiftMode );
        break;

      default:
        break;

    }


  myCameraMan->handleKeyRelease ( e );

  return true;
}




/**
  * Handles a mouse move
  */
bool InputListener::mouseMoved ( const OIS::MouseEvent &e )
{
  if ( !myIsInShiftMode )
    {
      myMouseCursor->updatePosition ( e.state.X.abs, e.state.Y.abs );

      if ( myMouseLeftClicked && ( ( e.state.X.abs != 0 ) && ( e.state.Y.abs != 0 ) && ( e.state.Y.abs != myWindow->getHeight() ) && ( e.state.X.abs != myWindow->getWidth() ) ) )
        {
          myCameraMan->setSceneCenter ( myViewer->getSceneCenter() );
          myCameraMan->turnCamera ( e.state.X.rel, e.state.Y.rel );

        }

      if ( myMouseRightClicked  && ( ( e.state.X.abs != 0 ) && ( e.state.Y.abs != 0 ) && ( e.state.Y.abs != myWindow->getHeight() ) && ( e.state.X.abs != myWindow->getWidth() ) ) )
        {
          myCameraMan->setSceneCenter ( myViewer->getSceneCenter() );
          myCameraMan->translateCamera ( e.state.X.rel, e.state.Y.rel );
          myViewer->setSceneCenter ( myCameraMan->getNewSceneCenter() );
        }

    }

  myCameraMan->handleMouseMove ( e );

  return true;
}




/**
  * Handles a window resize
  */
void InputListener::windowResized ( Ogre::RenderWindow* rw )
{

}



/**
  * makes the render loop stop
  */
void InputListener::stopRendering ( )
{
  myShutdown = true;
}




/**
  * makes the render loop starts
  */
void InputListener::startRendering ( )
{
  myShutdown = false;
}

