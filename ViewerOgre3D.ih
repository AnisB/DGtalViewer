/**
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 **/

/**
 * @file ViewerOgre3D.ih
* @author Anis Benyoub (\c anis.benyoub@insa-lyon.fr )
* Liris CNRS
*
* @date 2012/06/10
*
 * Implementation of inline methods defined in ViewerOgre3D.h
 *
 * This file is part of the DGtal library.
 */

///////////////////////////////////////////////////////////////////////////////
// IMPLEMENTATION of inline methods.
///////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
#include "ViewerOgre3D.h"
#include "Ogre3DDisplayFactory.h"
#include "Functions.h"
//////////////////////////////////////////////////////////////////////////////



///////////////////////////////////////////////////////////////////////////////
// Implementation of inline methods //



/**
  *  adding dgtal objects to the scene
  */
template <typename TDrawableWithDisplay3D>
inline
ViewerOgre3D &
ViewerOgre3D::operator<< ( const TDrawableWithDisplay3D & object )
{
//  BOOST_CONCEPT_ASSERT((CDrawableWithDisplay3D< TDrawableWithDisplay3D >));
  DGtal::Ogre3DDisplayFactory::draw ( *this, object );
  computeSceneCenter ( );
  updateInitialCameraPosition( );
  updateWrist();

  return *this;
}



/**
  *  Returns a dgtal object from selection
  */
template <typename TDrawableWithDisplay3D>
void ViewerOgre3D::operator>> ( TDrawableWithDisplay3D & object )
{
  if ( object.className() == "PointVector" )
    {
      mySelectionMode = true;
      start();
      const TDrawableWithDisplay3D * myPoint  = ( ( DrawableWithOgreWrapper<TDrawableWithDisplay3D> * ) ( mySelectedDGtalNode->getDGtalObject() ) )->getDgtalObject();
      object = ( *myPoint );
      mySelectionMode = false;
    }
}



/**
  * Using manipulate on a DGtal Object
  *  @param ptrfonction is a pointer on the function you want to useful
  *  @param anObject is the initial Object
  *  @param minValue && @param @maxValue  are the range you want to study the object on
  *  @param step is the evolution step.
  */
template <typename TDrawableWithDisplay3D>
void ViewerOgre3D::manipulate ( TDrawableWithDisplay3D & anObject, TDrawableWithDisplay3D & ( *ptrfonction ) ( TDrawableWithDisplay3D, int ), int minValue, int maxValue, int step )
{
  myManupilatingFlag = true;
  myMaxManupulating = maxValue;
  myMinManupulating = minValue;
  myCurrentManupulating = minValue;
  myStep = step;

  while ( myManupilatingFlag )
    {
      clearScene();
      TDrawableWithDisplay3D & Object = ptrfonction ( anObject,  myCurrentManupulating );
      ( *this ) << ( Object );
      start();
      delete &Object;
    }
}

/**
* @param objectName the name of the object (generally obtained
* with a 'object.className()').
*
* @return the current mode for the given object name or "" if no
* specific mode has been set.
*/
inline
std::string
DGtal::ViewerOgre3D::getMode ( const std::string & objectName ) const
  {
    ModeMapping::const_iterator itm = myModes.find ( objectName );
    return itm == myModes.end() ? "" : itm->second;
  }


/**
  *  Constructor.
  */
ViewerOgre3D::ViewerOgre3D() : myCurrentObject ( 0 ), mySelectionMode ( false )
{


  myRoot = new Ogre::Root ( "plugins.cfg", "ogre.cfg", "Ogre.log" );

  //Chargement des ressources et configuration
  initMaterials();

  if ( !initConfigs() )
    {
      return ;
    }

  //Creation de la scene principale
  mySceneMgr = myRoot->createSceneManager ( "DefaultSceneManager", "Fenetre Principale" );

  //DEVICES
  myWindow = myRoot->initialise ( true, "viewer3D" );



  //CREATION DE LA SCENE
  createScene();


  //Creation de l'input listener
  createFrameListener();


  myRayScnQuery = mySceneMgr->createRayQuery ( Ogre::Ray() );

  mySelectedDGtalNode = NULL;

  myUpperFatherNonRoot = NULL;

}

/**
  *  Destructor.
  */
ViewerOgre3D::~ViewerOgre3D()
{
  myRoot->destroySceneManager ( mySceneMgr );
  delete myRoot;
}



/**
  *  Rendering launch method.
  */
void ViewerOgre3D::start()
{

  myRoot->startRendering();
  myInputManager->startRendering();
}



/**
  * Initiate ressources
  */
void ViewerOgre3D::initMaterials()
{
  //Chargement des matÃ©riaux , des meshs et de tout ce qu'on a comme ressource
  Ogre::ConfigFile cf;
  cf.load ( "resources.cfg" );
  Ogre::ConfigFile::SectionIterator sectionIter = cf.getSectionIterator();

  Ogre::String sectionName, typeName, dataName;
  Ogre::ConfigFile::SettingsMultiMap * settings;
  Ogre::ConfigFile::SettingsMultiMap::iterator i;

  while ( sectionIter.hasMoreElements() )
    {
      sectionName = sectionIter.peekNextKey();
      settings = sectionIter.getNext();

      for ( i = settings->begin(); i != settings->end(); ++i )
        {
          typeName = i->first;
          dataName = i->second;

          Ogre::ResourceGroupManager::getSingleton().addResourceLocation ( dataName, typeName, sectionName );
        }
    }

  Ogre::ResourceGroupManager::getSingleton().initialiseAllResourceGroups();

  //fin chargement materials
}


/**
  *  Config initiate
  */
bool ViewerOgre3D::initConfigs()
{
  if ( !myRoot->restoreConfig() )
    {
      if ( !myRoot->showConfigDialog() )
        {
          return false; //erreur de chargement config
        }
    }

  return true;
}

/**
  *  Scene create
  */
void ViewerOgre3D::createScene()
{
  Ogre::TextureManager::getSingleton().setDefaultNumMipmaps ( 5 );
  Ogre::ResourceGroupManager::getSingleton().initialiseAllResourceGroups();


  mySceneMgr->setAmbientLight ( Ogre::ColourValue ( 0.4, 0.4, 0.4 ) );


  Ogre::Light * light = mySceneMgr->createLight ( "Light" );
  light->setType ( Ogre::Light::LT_POINT );
  light->setDirection ( Ogre::Vector3 ( 1, -1, 0 ) );
  light->setDiffuseColour ( 0.8, 0.8, 0.8 );
  light->setSpecularColour ( 0.8, 0.5, 0.8 );
  light->setPosition ( 100, 250, 100 );

  //Camera
  myCamera = mySceneMgr->createCamera ( "mYCamera" );
  myCamera->setFarClipDistance ( 10000 );
  myCamera->setNearClipDistance ( 0.01 );
  myCamera->setPosition ( Ogre::Vector3 ( 0, 10, 500 ) );
  myCamera->lookAt ( Ogre::Vector3 ( 0, 0, 0 ) );

  //Screens
  Ogre::Viewport* vp = myWindow->addViewport ( myCamera );
  vp->setBackgroundColour ( Ogre::ColourValue ( 0.2, 0.2, 0.2 ) );

  // Parametrage du point de vue
  myCamera->setAspectRatio ( Ogre::Real ( vp->getActualWidth() ) / Ogre::Real ( vp->getActualHeight() ) );

  myRootNode = new DGtalNode ( mySceneMgr );
  Representation * hisRepresentation = new Representation ( mySceneMgr, mySceneMgr->getRootSceneNode()->createChildSceneNode ( "RootNode" ), "RootNode" );
  myRootNode->setRepresentation ( hisRepresentation );
  myRootNode->setFather ( NULL );
  myRootNode->setRoot();

  drawAxes();
  drawWrist();

}


/**
  *  Frame listenner creartion
  */
void ViewerOgre3D::createFrameListener()
{
  myInputManager = new InputListener ( myWindow, this, myCamera, mySceneMgr );
  myRoot->addFrameListener ( myInputManager );
}


/**
  *  Get a son node ( of the root one)
  */
Ogre::SceneNode * ViewerOgre3D::getANode()
{
  return myRootNode->getNode()->createChildSceneNode();
}


/**
*  looks for a point and changes the current selection if found (x, y)
*  the mouse coordinates and (h,w) the window dimension
*/

void ViewerOgre3D::lookForIt ( unsigned int x, unsigned int y, unsigned int h, unsigned int w )
{

  cout << "COucou" << endl;
  Representation * temp = NULL;
  double DistanceToCamera = -1;


  Ogre::Ray mouseRay = myCamera->getCameraToViewportRay ( ( double ) x / ( double ) w, ( double ) y / ( double ) h );
  myRayScnQuery->setRay ( mouseRay );
  Ogre::RaySceneQueryResult &result = myRayScnQuery->execute();
  Ogre::RaySceneQueryResult::iterator itr;


  for ( itr = result.begin( ); itr != result.end(); itr++ )
    {

      if ( itr->movable )
        {
          Representation * Encloser = findRepresentation ( itr->movable->getName() );

          if ( Encloser != NULL )
            {
              Ogre::Vector3 AVector ( myInputManager->getCameraMan()->getSceneNode()->getPosition() - Encloser->getNode()->_getDerivedPosition() );// mSceneMgr->getRootSceneNode()->convertLocalToWorldPosition ( Encloser->getNode()->getPosition() ) );
              double localDistance = AVector.length();

              if ( DistanceToCamera == -1 )
                {
                  DistanceToCamera = localDistance;
                  temp = Encloser;
                }
              else
                if ( ( DistanceToCamera >= localDistance ) )
                  {
                    DistanceToCamera = localDistance;
                    temp = Encloser;
                  }
            }
        }
    }

  if ( mySelectedDGtalNode != NULL )
    {
      mySelectedDGtalNode->unselect();
    }

  if ( myUpperFatherNonRoot != NULL )
    {
      myUpperFatherNonRoot ->unselect();
    }


  if ( temp != NULL )
    {
      mySelectedDGtalNode = temp->getAttachedParent();
      myUpperFatherNonRoot = mySelectedDGtalNode->getUpperNonRootNode();

      if ( mySelectionMode )
        {
          myInputManager->stopRendering();
        }

      if ( myUpperFatherNonRoot != NULL )
        {
          myUpperFatherNonRoot ->groupSelect();
        }



      if ( mySelectedDGtalNode != NULL )
        {
          mySelectedDGtalNode->select();
        }
    }
  else
    {
      mySelectedDGtalNode = NULL;
      myUpperFatherNonRoot = NULL;
    }


}






/**
  *  adds a line
  */
Representation * ViewerOgre3D::addLine ( double x1, double y1, double z1, double x2, double y2, double z2, Ogre::SceneNode * aNode )
{

  Ogre::SceneNode * m_bodySceneNode = aNode->createChildSceneNode();
  Ogre::ManualObject  * m_ent  = mySceneMgr->createManualObject ( );
  m_ent->begin ( "BaseWhiteNoLighting", Ogre::RenderOperation::OT_LINE_LIST );
  m_ent->colour ( 0.5, 0.0, 1.0 );
  m_ent->position ( x1*scaleFactor, y1*scaleFactor, z1*scaleFactor );
  m_ent->position ( x2*scaleFactor, y2*scaleFactor, z2*scaleFactor );
  m_ent->end();
  m_bodySceneNode->attachObject ( m_ent );

  DGtal::Representation * aRepresentation = new Representation ( mySceneMgr, m_ent, m_bodySceneNode, m_ent->getName(), "ManualObject" );
  aRepresentation->addMaterial ( aNode->getName()  );
  return aRepresentation;
}

/**
  *  adds a point
  */
Representation * ViewerOgre3D::addPoint ( double x, double y, double z,
    Ogre::SceneNode * aNode, double factor )
{
  Ogre::SceneNode * m_bodySceneNode = aNode->createChildSceneNode();
  Ogre::Entity  * m_ent = mySceneMgr->createEntity ( Ogre::SceneManager::PT_SPHERE );
  m_ent->setMaterialName ( "Texture/Selected" );
  m_ent->setMaterialName ( "Texture/Unselected" );
  m_ent->setMaterialName ( aNode->getName() );

  m_bodySceneNode->attachObject ( m_ent );
  m_bodySceneNode->setPosition ( Ogre::Vector3 ( x*scaleFactor, y*scaleFactor, z*scaleFactor ) );
  m_bodySceneNode->setScale ( factor*scaleFactor / 1000.0, factor*scaleFactor / 1000.0, factor*scaleFactor / 1000.0 );
  DGtal::Representation * aRepresentation = new Representation ( mySceneMgr, m_ent, m_bodySceneNode, m_ent->getName(), "Entity" );
  aRepresentation->addMaterial (  aNode->getName() );
  return aRepresentation;
}


/**
  *  adds a voxel
  */
Representation  * ViewerOgre3D::addVoxel ( double x, double y, double z, Ogre::SceneNode * aNode,
    DGtal::Color aColor )
{


  Ogre::SceneNode * m_bodySceneNode = aNode->createChildSceneNode();
  
  Ogre::Entity  * m_ent = mySceneMgr->createEntity ( Ogre::SceneManager::PT_CUBE );

  m_ent->setMaterialName ( "Texture/Selected" );
  m_ent->setMaterialName ( "Texture/Unselected" );
  m_ent->setMaterialName ( aNode->getName() );
  m_bodySceneNode->attachObject ( m_ent );
  
  m_bodySceneNode->setPosition ( Ogre::Vector3 ( x*scaleFactor, y*scaleFactor, z*scaleFactor ) );
  m_bodySceneNode->setScale ( scaleFactor / 100.0,
			      scaleFactor / 100.0, 
			      scaleFactor / 100.0 );
  
  DGtal::Representation * aRepresentation = new Representation ( mySceneMgr,
								 m_ent, m_bodySceneNode,
								 m_ent->getName(), "Entity" );
  aRepresentation->addMaterial ( aNode->getName() );
  return aRepresentation;

}


/**
  *  adds a kalimsky voxel
  */
Representation * ViewerOgre3D::addKSVoxel ( int x, int y, int z, Ogre::SceneNode * aNode )
{
  Ogre::SceneNode * m_bodySceneNode = aNode->createChildSceneNode();
  Ogre::Entity  * m_ent = mySceneMgr->createEntity ( Ogre::SceneManager::PT_CUBE );

  m_ent->setMaterialName ( "Texture/Selected" );
  m_ent->setMaterialName ( "Texture/Unselected" );
    m_ent->setMaterialName ( aNode->getName() );

  m_bodySceneNode->attachObject ( m_ent );
  
  m_bodySceneNode->setPosition ( Ogre::Vector3 ( ( x + 0.5 ) *scaleFactor,
						 ( y + 0.5 ) *scaleFactor,
						 ( z + 0.5 ) *scaleFactor ) );
  
  
  m_bodySceneNode->setScale ( scaleFactor / 120.0, scaleFactor / 120.0, scaleFactor / 120.0 );
  DGtal::Representation * aRepresentation = new Representation ( mySceneMgr,
								 m_ent, m_bodySceneNode, 
								 m_ent->getName(), "Entity" );
  aRepresentation->addMaterial (  aNode->getName());
  return aRepresentation;
}


/**
  *  adds a kalimsky surfel
  */
Representation * ViewerOgre3D::addKSSurfel ( double x, double y, double z,
    bool xSurfel, bool ySurfel, bool zSurfel,
    Ogre::SceneNode * aNode )
{
  Ogre::SceneNode * m_bodySceneNode = aNode->createChildSceneNode();
  Ogre::Entity  * m_ent = mySceneMgr->createEntity ( Ogre::SceneManager::PT_CUBE );


  m_ent->setMaterialName ( "Texture/Selected" );
  m_ent->setMaterialName ( "Texture/Unselected" );
  m_ent->setMaterialName ( aNode->getName() );
  if ( !xSurfel )
    {
      m_bodySceneNode->setScale ( scaleFactor / 2500.0, scaleFactor / 175.0, scaleFactor / 175.0 );

      m_bodySceneNode->attachObject ( m_ent );
      m_bodySceneNode->setPosition ( Ogre::Vector3 ( ( x + 0.5 ) *scaleFactor, ( y + 0.5 ) *scaleFactor, ( z + 0.5 ) *scaleFactor ) + Ogre::Vector3::UNIT_X* ( -0.5*scaleFactor ) );
    }
  else
    if ( !ySurfel )
      {
        m_bodySceneNode->setScale ( scaleFactor / 175.0, scaleFactor / 2500.0, scaleFactor / 175.0 );

        m_bodySceneNode->attachObject ( m_ent );

        m_bodySceneNode->setPosition ( Ogre::Vector3 ( ( x + 0.5 ) *scaleFactor, ( y + 0.5 ) *scaleFactor, ( z + 0.5 ) *scaleFactor )  + Ogre::Vector3::UNIT_Y* ( -0.5*scaleFactor ) );
      }
    else
      if ( !zSurfel )
        {
          m_bodySceneNode->setScale ( scaleFactor / 175.0, scaleFactor / 175.0, scaleFactor / 2500.0 );

          m_bodySceneNode->attachObject ( m_ent );
          m_bodySceneNode->setPosition ( Ogre::Vector3 ( ( x + 0.5 ) *scaleFactor, ( y + 0.5 ) *scaleFactor, ( z + 0.5 ) *scaleFactor ) + Ogre::Vector3::UNIT_Z* ( -0.5*scaleFactor ) );

        }


  DGtal::Representation * aRepresentation = new Representation ( mySceneMgr, m_ent, m_bodySceneNode, m_ent->getName(), "Entity" );

  aRepresentation->addMaterial ( aNode->getName());
  return aRepresentation;
}



/**
  * adds a kalimsky pointel
  */
Representation * ViewerOgre3D::addKSPointel ( double x, double y, double z, Ogre::SceneNode * aNode )
{
  Ogre::SceneNode * m_bodySceneNode = aNode->createChildSceneNode();
  Ogre::Entity  * m_ent = mySceneMgr->createEntity ( Ogre::SceneManager::PT_SPHERE );

  m_ent->setMaterialName ( "Texture/Selected" );
  m_ent->setMaterialName ( "Texture/Unselected" );
  m_ent->setMaterialName ( aNode->getName());
  m_bodySceneNode->attachObject ( m_ent );
  m_bodySceneNode->setPosition ( Ogre::Vector3 ( ( x + 0.5 ) *scaleFactor, ( y + 0.5 ) *scaleFactor, ( z + 0.5 ) *scaleFactor ) );
  m_bodySceneNode->setScale ( scaleFactor / 900.0, scaleFactor / 900.0, scaleFactor / 900.0 );
  DGtal::Representation * aRepresentation = new Representation ( mySceneMgr, m_ent, m_bodySceneNode, m_ent->getName(), "Entity" );
  aRepresentation->addMaterial ( aNode->getName());
  return aRepresentation;
}

/**
  * adds a kalimsky pointel
  */
Representation * ViewerOgre3D::addKSLinel ( double x1, double y1, double z1, double x2, double y2, double z2, Ogre::SceneNode * aNode )
{

  Ogre::SceneNode * m_bodySceneNode = aNode->createChildSceneNode();
  Ogre::Entity  * m_ent = mySceneMgr->createEntity ( Ogre::SceneManager::PT_CUBE );

  m_ent->setMaterialName ( "Texture/Selected" );
  m_ent->setMaterialName ( "Texture/Unselected" );
    m_ent->setMaterialName ( aNode->getName() );
  m_bodySceneNode->attachObject ( m_ent );

  if ( fabs ( ( x1 - x2 ) ) > 0.001 )
    {
      m_bodySceneNode->setScale ( scaleFactor / 150.0, scaleFactor / 2000.0, scaleFactor / 2000.0 );
      m_bodySceneNode->setPosition ( Ogre::Vector3 ( ( x1 + 1.0 ) *scaleFactor, ( y1 + 0.5 ) *scaleFactor, ( z1 + 0.5 ) *scaleFactor ) );
    }
  else
    if ( fabs ( ( y1 - y2 ) ) > 0.001 )
      {
        m_bodySceneNode->setScale ( scaleFactor / 2000.0, scaleFactor / 150.0, scaleFactor / 2000.0 );
        m_bodySceneNode->setPosition ( Ogre::Vector3 ( ( x1 + 0.5 ) *scaleFactor, ( y1 + 1.0 ) *scaleFactor, ( z1 + 0.5 ) *scaleFactor ) );
      }
    else
      if ( fabs ( ( z1 - z2 ) ) > 0.001 )
        {
          m_bodySceneNode->setScale ( scaleFactor / 2000.0, scaleFactor / 2000.0, scaleFactor / 150.0 );
          m_bodySceneNode->setPosition ( Ogre::Vector3 ( ( x1 + 0.5 ) *scaleFactor, ( y1 + 0.5 ) *scaleFactor, ( z1 + 1.0 ) *scaleFactor ) );
        }

  DGtal::Representation * aRepresentation = new Representation ( mySceneMgr, m_ent, m_bodySceneNode, m_ent->getName(), "Entity" );

  aRepresentation->addMaterial ( aNode->getName());
  return aRepresentation;


}



/**
  *  Add a DgtalNode to the list
  */
void ViewerOgre3D::addToList ( DGtalNode * aNode )
{
  myNodes[aNode->getName() ] = aNode;
}


/**
  *  Find the representation coressponding to a point
  */
Representation * ViewerOgre3D::findRepresentation ( std::string aName )
{


  std::map<std::string, DGtalNode *>::iterator aNode = myNodes.begin();

  Representation * theRepresentationToGet = NULL;

  while ( ( aNode != myNodes.end() ) && ( theRepresentationToGet == NULL ) )
    {


      theRepresentationToGet = ( *aNode ).second->getRepresentation ( aName );

      if ( theRepresentationToGet != NULL )
        {

        }
      else
        {
          aNode++;
        }
    }

  return ( theRepresentationToGet );


}


/**
  *  clears the scene
  */
void ViewerOgre3D::clearScene()
{
  myRootNode->clear();
  mySelectedDGtalNode = NULL;
  myUpperFatherNonRoot = NULL;
  myNodes.clear();
}


/**
  *   Displays the scene on the standard output
  */
void ViewerOgre3D::sceneDisplay()
{
  myRootNode->display ( 0 );
}


/**
  * draws the axes
  */
void ViewerOgre3D::drawAxes()
{

  // Coordinate system Drawing
  myAxis =  mySceneMgr->createManualObject ( "Entity_Axis" );
  myAxisNode = mySceneMgr->getRootSceneNode()->createChildSceneNode ( "Node_Axis" );

  myAxis->begin ( "BaseWhiteNoLighting", Ogre::RenderOperation::OT_LINE_LIST );


  myAxis->colour ( 1.0, 0.0, 0.0 );
  // Ex drawing
  myAxis->position ( 0, 0, 0 );
  myAxis->position ( 200, 0, 0 );
  myAxis->position ( 180, 0, 10 );
  myAxis->position ( 200, 0, 0 );
  myAxis->position ( 180, 0, -10 );
  myAxis->position ( 200, 0, 0 );
  myAxis->colour ( 0.0, 1.0, 0.0 );

  //Ey Drawing
  myAxis->position ( 0, 0, 0 );
  myAxis->position ( 0, 200, 0 );
  myAxis->position ( 10, 180, 0 );
  myAxis->position ( 0, 200, 0 );
  myAxis->position ( -10, 180, 0 );
  myAxis->position ( 0, 200, 0 );
  myAxis->colour ( 0.0, 0.0, 1.0 );

  //Ez Drawing
  myAxis->position ( 0, 0, 0 );
  myAxis->position ( 0, 0, 200 );
  myAxis->position ( 10, 0, 180 );
  myAxis->position ( 0, 0, 200 );
  myAxis->position ( -10, 0, 180 );
  myAxis->position ( 0, 0, 200 );

  myAxis->end();

  myAxisNode->attachObject ( myAxis );
}




/**
  * draws the wrist
  */
void ViewerOgre3D::drawWrist()
{

  myWrist = mySceneMgr->createManualObject ( "Wrist" );


  float const radius = 200,
                       thickness = 7, // Of course this must be less than the radius value.
                                   accuracy = 35;

  myWrist->begin ( "BaseWhiteNoLighting",  Ogre::RenderOperation::OT_LINE_LIST );
  myWrist->colour ( 0.5, 0.8, 1.0 );
  unsigned point_index = 0;

  for ( float theta = 0; theta <= 2 * Ogre::Math::PI; theta += Ogre:: Math::PI / accuracy )
    {
      myWrist->position ( radius * cos ( theta ),
                          0,
                          radius * sin ( theta ) );
      myWrist->position ( radius * cos ( theta - Ogre::Math::PI / accuracy ),
                          0,
                          radius * sin ( theta - Ogre::Math::PI / accuracy ) );
      myWrist->position ( ( radius - thickness ) * cos ( theta - Ogre::Math::PI / accuracy ),
                          0,
                          ( radius - thickness ) * sin ( theta - Ogre::Math::PI / accuracy ) );
      myWrist->position ( ( radius - thickness ) * cos ( theta ),
                          0,
                          ( radius - thickness ) * sin ( theta ) );
    }

  myWrist->end();

  myWrist->begin ( "BaseWhiteNoLighting",  Ogre::RenderOperation::OT_LINE_LIST );

  myWrist->position ( radius + 100, 0, 0 );
  myWrist->position ( radius + 100 - 30, 0, -30 );

  myWrist->position ( radius + 100 - 30, 0, -30 );
  myWrist->position ( radius + 100 - 60, 0, 0 );

  myWrist->position ( radius + 100 - 60, 0, 0 );
  myWrist->position ( radius + 100 - 30, 0, 0 + 30 );

  myWrist->position ( radius + 100 - 30, 0, 0 + 30 );
  myWrist->position ( radius + 100, 0, 0 );


  myWrist->end();
  myWrist->begin ( "BaseWhiteNoLighting",  Ogre::RenderOperation::OT_LINE_LIST );

  for ( float theta = 0; theta <= 2 * Ogre::Math::PI; theta += Ogre:: Math::PI / accuracy )
    {
      myWrist->position ( 0, radius * cos ( theta ),
                          radius * sin ( theta ) );
      myWrist->position ( 0, radius * cos ( theta - Ogre::Math::PI / accuracy ),
                          radius * sin ( theta - Ogre::Math::PI / accuracy ) );
      myWrist->position ( 0, ( radius - thickness ) * cos ( theta - Ogre::Math::PI / accuracy ),
                          ( radius - thickness ) * sin ( theta - Ogre::Math::PI / accuracy ) );
      myWrist->position ( 0, ( radius - thickness ) * cos ( theta ),
                          ( radius - thickness ) * sin ( theta ) );
    }

  myWrist->end();

  myWrist->begin ( "BaseWhiteNoLighting",  Ogre::RenderOperation::OT_LINE_LIST );
  myWrist->colour ( 0.5, 0.8, 1.0 );
  myWrist->position ( 0, radius + 100, 0 );
  myWrist->position ( 0, radius + 100 - 30, -30 );

  myWrist->position ( 0, radius + 100 - 30, -30 );
  myWrist->position ( 0, radius + 100 - 60, 0 );

  myWrist->position ( 0, radius + 100 - 60, 0 );
  myWrist->position ( 0, radius + 100 - 30, 0 + 30 );

  myWrist->position ( 0, radius + 100 - 30, 0 + 30 );
  myWrist->position ( 0, radius + 100, 0 );


  myWrist->end();


  myWristNode = mySceneMgr->getRootSceneNode()->createChildSceneNode();
  myWristNode->attachObject ( myWrist );
}




/**
  *  Flips the axis visibility .
  */
void ViewerOgre3D::changeAxisVisibility()
{
  myAxisNode->flipVisibility();
}


/**
  *   Returns the lower point of the scene
  */
Ogre::Vector3 ViewerOgre3D::getLowerPosition()
{
  Ogre::Vector3 low = Ogre::Vector3 ( 0, 0, 0 );
  std::map<std::string, DGtalNode *>::iterator them = myNodes.begin();

  while ( them != myNodes.end() )
    {
      if ( ( low.z ) > ( ( *them ).second->getNode()->getPosition().z ) )
        {
          low = ( *them ).second->getNode()->getPosition();
        }

      them ++;
    }

  return low;
}



/**
  *   Returns the upper point of the scene
  */
Ogre::Vector3 ViewerOgre3D::getUpperPosition()
{
  Ogre::Vector3 up = Ogre::Vector3 ( 0, 0, 0 );
  std::map<std::string, DGtalNode *>::iterator them = myNodes.begin();

  while ( them != myNodes.end() )
    {
      if ( ( up.z ) < ( ( *them ).second->getNode()->getPosition().z ) )
        {
          up = ( *them ).second->getNode()->getPosition();
        }

      them ++;
    }

  return up;
}


/**
  *  Returns the leftest point
  */
Ogre::Vector3 ViewerOgre3D::getLeftestPosition()
{
  Ogre::Vector3 up = Ogre::Vector3 ( 0, 0, 0 );
  std::map<std::string, DGtalNode *>::iterator them = myNodes.begin();

  while ( them != myNodes.end() )
    {
      if ( ( up.y ) > ( ( *them ).second->getNode()->getPosition().y ) )
        {
          up = ( *them ).second->getNode()->getPosition();
          them ++;
        }

      them ++;
    }

  return up;
}


/**
  *  Returns the Fowardest point
  */
Ogre::Vector3 ViewerOgre3D::getFowardestPosition()
{
  Ogre::Vector3 up = Ogre::Vector3 ( 0, 0, 0 );
  std::map<std::string, DGtalNode *>::iterator them = myNodes.begin();

  while ( them != myNodes.end() )
    {
      if ( ( up.x ) > ( ( *them ).second->getNode()->getPosition().x ) )
        {
          up = ( *them ).second->getNode()->getPosition();
          them ++;
        }

      them ++;
    }

  return up;
}

/**
  *  updates the manipulating value
  */
void ViewerOgre3D::newManipulatingValue ( int change )
{
  if ( change > 0 )
    {
      if ( ( myCurrentManupulating + myStep ) < myMaxManupulating )
        {
          myCurrentManupulating += myStep;
          myInputManager->stopRendering();
        }
    }
  else
    {
      if ( ( myCurrentManupulating - myStep ) > myMinManupulating )
        {
          myCurrentManupulating -= myStep;
          myInputManager->stopRendering();
        }
    }

}

/**
  *  Stops the manipulating mode
  */
void ViewerOgre3D::abortManupulating()
{
  myInputManager->stopRendering();
  myManupilatingFlag = false;
}


/**
  *  Set the near and far clip distance of the camera
  */
void ViewerOgre3D::setNearFar ( double near, double far )
{
  myCamera->setNearClipDistance ( scaleFactor*near );
  myCamera->setFarClipDistance ( scaleFactor*far );
}


void ViewerOgre3D::setCameraUpVector ( Ogre::Vector3   anUp )
{
  myCamera->setFixedYawAxis ( true, anUp );
}




/**
  *  set's the camera upvector
  */
void ViewerOgre3D::setCameraDirection ( Ogre::Vector3  aPoint )
{
  myCamera->lookAt ( aPoint );
}


/**
  *  Set's the camera position
  */
void ViewerOgre3D::setCameraPosition ( Ogre::Vector3  aPosition )
{
  myCamera->setPosition ( aPosition );
}

/**
  *  adds a clipping plane
  */
void ViewerOgre3D::addClippingPlane ( double a, double b, double c, double d )
{
  myRoot->getRenderSystem()->addClipPlane ( Ogre::Plane ( a, b, c, d ) );
}


/**
  *  Computes the scene center
  */
void  ViewerOgre3D::computeSceneCenter ( )
{
  Ogre::Vector3 upper = getUpperPosition();
  Ogre::Vector3 lower = getLowerPosition();
  mySceneCenter = ( upper + lower ) / 2.0;
}




/**
  * Updates the wrist position
  */
void  ViewerOgre3D::updateWrist ( )
{
  myWristNode->setPosition ( mySceneCenter );

}

/**
  * Sets the new initial position of the cameraman
  */
void ViewerOgre3D::updateInitialCameraPosition( )
{
  Ogre::Vector3 initialPos = getFowardestPosition() + getLeftestPosition() + getUpperPosition();
  myInputManager->getCameraMan()->setInitialPosition ( initialPos );

}

/**
  *  Creates a texture starting from a DGtal color
  */
//void ViewerOgre3D::createMaterial ( std::string  aName,int red,int green, int blue, int transparency)
void ViewerOgre3D::createMaterial(std::string  aName,DGtal::Color & aColor)
{
  Ogre::MaterialManager& lMaterialManager = Ogre::MaterialManager::getSingleton();
  Ogre::MaterialPtr lMaterial = lMaterialManager.create ( aName, "General" );
  Ogre::Technique* lFirstTechnique = lMaterial->getTechnique ( 0 );
  Ogre::Pass* lFirstPass = lFirstTechnique->getPass ( 0 );

  Ogre::ColourValue lSelfIllumnationColour ( ( double ) aColor.red() / 255.0, ( double ) aColor.green() / 255.0, ( double ) aColor.blue() / 255.0, ( double ) aColor.alpha()/ 255.0 );
  lFirstPass->setSelfIllumination ( lSelfIllumnationColour );


  Ogre::ColourValue lDiffuseColour ( ( double ) aColor.red() / 255.0, ( double ) aColor.green() / 255.0, ( double ) aColor.blue() / 255.0, ( double ) aColor.alpha()/ 255.0);
  lFirstPass->setDiffuse ( lDiffuseColour );

  Ogre::ColourValue lAmbientColour (( double ) aColor.red() / 255.0, ( double ) aColor.green() / 255.0, ( double ) aColor.blue() / 255.0, ( double ) aColor.alpha()/ 255.0 );
  lFirstPass->setAmbient ( lAmbientColour );

  // I want the specular to not be transparent.
  Ogre::ColourValue lSpecularColour ( ( double ) aColor.red() / 255.0, ( double ) aColor.green() / 255.0, ( double ) aColor.blue() / 255.0, ( double ) aColor.alpha()/ 255.0 );
  lFirstPass->setSpecular ( lSpecularColour );

  Ogre::Real lShininess = 64.0f;
  lFirstPass->setShininess ( lShininess );



  // This pass will use the "alpha" to make things transparent.
  // I disallow depth write (don't write in the Z-Buffer, check an opengl book for details).
  lFirstPass->setSceneBlending ( Ogre::SBT_TRANSPARENT_ALPHA );
  lFirstPass->setDepthWriteEnabled ( false );
}

