#include "ViewerOgre3D.h"
#include "Ogre3DDisplayFactory.h"
#include "Functions.h"

namespace DGtal
  {
    template <typename TDrawableWithDisplay3D>
    inline
    ViewerOgre3D &
    ViewerOgre3D::operator<< ( const TDrawableWithDisplay3D & object )
    {
// BOOST_CONCEPT_ASSERT((CDrawableWithDisplay3D< TDrawableWithDisplay3D >));
      DGtal::Ogre3DDisplayFactory::draw ( *this, object );
      Ogre::Vector3 upper = getUpperPosition();
      Ogre::Vector3 lower = getLowerPosition();
      mySceneCenter=(upper+lower)/2.0;
      return *this;

    }

    template <typename TDrawableWithDisplay3D>
    void ViewerOgre3D::operator>> ( TDrawableWithDisplay3D & object )
    {
      if ( object.className() == "PointVector" )
        {
          SelectionMode = true;
          Start();
          const TDrawableWithDisplay3D * myPoint  = ( ( TDrawable<TDrawableWithDisplay3D> * ) ( SelectedDGtalNode->getDGtalObject() ) )->getDgtalObject();
          object = ( *myPoint );
          SelectionMode = false;
        }
    }


    template <typename TDrawableWithDisplay3D>
    void ViewerOgre3D::functionApply(TDrawableWithDisplay3D & anObject, void (*ptrfonction)(TDrawableWithDisplay3D,int), int minValue, int maxValue)
    {
      ClearScene();
      Start();
      TDrawableWithDisplay3D & Object = ptrfonction ( anObject,  minValue );
    }




    ViewerOgre3D::ViewerOgre3D() : mCurrentObject ( 0 ), SelectionMode ( false )
    {


      mRoot = new Ogre::Root ( "plugins.cfg", "ogre.cfg", "Ogre.log" );

      //CHARGEMENT CONFIG & RESSOURCES
      InitMaterials();

      if ( !InitConfigs() )
        {
          return ;
        }

      //Creation de la scene principale
      mSceneMgr = mRoot->createSceneManager ( "DefaultSceneManager", "Fenetre Principale" );

      //DEVICES
      mWindow = mRoot->initialise ( true, "viewer3D" );



      std::cout << "Creation de la scene" << std::endl;

      //CREATION DE LA SCENE
      CreateScene();

      std::cout << "Fin de la creation de la scene" << std::endl;


      std::cout << "Creation du frame listenner" << std::endl;

      //Creation de l'input listener
      CreateFrameListener();

      std::cout << "Fin de la creation du frame listenner" << std::endl;

      // RAy scene
      //but we also want to set up our raySceneQuery after everything has been initialized
      mRayScnQuery = mSceneMgr->createRayQuery ( Ogre::Ray() );

      SelectedDGtalNode = NULL;

      UpperFatherNonRoot = NULL;
      
      
      myManipulatingFlag=false;

    }


    ViewerOgre3D::~ViewerOgre3D()
    {

    }


    void ViewerOgre3D::Start()
    {

      //DEBUT DE LA BOUCLE DE RENDU
      mRoot->startRendering();
      mInputManager->startRendering();

      //-------------------------------------Phase destruction

//  mRoot->destroySceneManager(mSceneMgr);
//  delete mRoot;

    }

    void ViewerOgre3D::InitMaterials()
    {
      //Chargement des matÃ©riaux , des meshs et de tout ce qu'on a comme ressource
      Ogre::ConfigFile cf;
      cf.load ( "resources.cfg" );
      Ogre::ConfigFile::SectionIterator sectionIter = cf.getSectionIterator();

      Ogre::String sectionName, typeName, dataName;
      Ogre::ConfigFile::SettingsMultiMap * settings;
      Ogre::ConfigFile::SettingsMultiMap::iterator i;

      while ( sectionIter.hasMoreElements() )
        {
          sectionName = sectionIter.peekNextKey();
          settings = sectionIter.getNext();

          for ( i = settings->begin(); i != settings->end(); ++i )
            {
              typeName = i->first;
              dataName = i->second;

              Ogre::ResourceGroupManager::getSingleton().addResourceLocation ( dataName, typeName, sectionName );
            }
        }

      Ogre::ResourceGroupManager::getSingleton().initialiseAllResourceGroups();

      //fin chargement materials
    }

    bool ViewerOgre3D::InitConfigs()
    {
      if ( !mRoot->restoreConfig() )
        {
          if ( !mRoot->showConfigDialog() )
            {
              return false; //erreur de chargement config
            }
        }

      return true;
    }


    void ViewerOgre3D::CreateScene()
    {
      Ogre::TextureManager::getSingleton().setDefaultNumMipmaps ( 200 );
      Ogre::ResourceGroupManager::getSingleton().initialiseAllResourceGroups();


      mSceneMgr->setAmbientLight ( Ogre::ColourValue ( 0.4, 0.4, 0.4 ) );


      Ogre::Light * light = mSceneMgr->createLight ( "Light" );
      light->setType ( Ogre::Light::LT_POINT );
      light->setDirection ( Ogre::Vector3 ( 1, -1, 0 ) );
      light->setDiffuseColour ( 0.8, 0.8, 0.8 );
      light->setSpecularColour ( 0.8, 0.5, 0.8 );
      light->setPosition ( 100, 250, 100 );

      //Camera
      mCamera = mSceneMgr->createCamera ( "mYCamera" );
      mCamera->setFarClipDistance ( 10000 );
      mCamera->setNearClipDistance ( 0.01 );
      mCamera->setPosition ( Ogre::Vector3 ( 0, 10, 500 ) );
      mCamera->lookAt ( Ogre::Vector3 ( 0, 0, 0 ) );

      //Screens
      Ogre::Viewport* vp = mWindow->addViewport ( mCamera );
      vp->setBackgroundColour ( Ogre::ColourValue ( 0, 0, 0 ) );

      // Parametrage du point de vue
      mCamera->setAspectRatio ( Ogre::Real ( vp->getActualWidth() ) / Ogre::Real ( vp->getActualHeight() ) );

      mRootNode = new DGtalNode ( mSceneMgr );
      Representation * hisRepresentation = new Representation ( mSceneMgr, mSceneMgr->getRootSceneNode()->createChildSceneNode ( "RootNode" ), "RootNode" );
      mRootNode->setRepresentation ( hisRepresentation );
      mRootNode->setFather ( NULL );
      mRootNode->setRoot();

      Ogre::ManualObject * circle = mSceneMgr->createManualObject ( "circle_name" );

      float const radius = 70,
                           thickness = 1, // Of course this must be less than the radius value.
                                       accuracy = 35;

      circle->begin ( "BaseWhiteNoLighting",  Ogre::RenderOperation::OT_TRIANGLE_LIST );

      unsigned point_index = 0;

      for ( float theta = 0; theta <= 2 * Ogre::Math::PI; theta += Ogre:: Math::PI / accuracy )
        {
          circle->position ( radius * cos ( theta ),
                             0,
                             radius * sin ( theta ) );
          circle->position ( radius * cos ( theta - Ogre::Math::PI / accuracy ),
                             0,
                             radius * sin ( theta - Ogre::Math::PI / accuracy ) );
          circle->position ( ( radius - thickness ) * cos ( theta - Ogre::Math::PI / accuracy ),
                             0,
                             ( radius - thickness ) * sin ( theta - Ogre::Math::PI / accuracy ) );
          circle->position ( ( radius - thickness ) * cos ( theta ),
                             0,
                             ( radius - thickness ) * sin ( theta ) );
          // Join the 4 vertices created above to form a quad.
          circle->quad ( point_index, point_index + 1, point_index + 2, point_index + 3 );
          point_index += 4;
        }

      circle->end();

      mSceneMgr->getRootSceneNode()->createChildSceneNode()->attachObject ( circle );



      drawAxes();




    }

    void ViewerOgre3D::CreateFrameListener()
    {
      mInputManager = new InputListener ( mWindow, this, mCamera, mSceneMgr );
      mRoot->addFrameListener ( mInputManager );
    }



    Ogre::SceneNode * ViewerOgre3D::getANode()
    {
      return mRootNode->getNode()->createChildSceneNode();
    }

    void ViewerOgre3D::LookForIt ( unsigned int x, unsigned int y, unsigned int h, unsigned int w )
    {
      Representation * temp = NULL;
      double DistanceToCamera = -1;


      Ogre::Ray mouseRay = mCamera->getCameraToViewportRay ( ( double ) x / ( double ) w, ( double ) y / ( double ) h );
      mRayScnQuery->setRay ( mouseRay );
      Ogre::RaySceneQueryResult &result = mRayScnQuery->execute();
      Ogre::RaySceneQueryResult::iterator itr;


      for ( itr = result.begin( ); itr != result.end(); itr++ )
        {

          if ( itr->movable )
            {
              Representation * Encloser = findRepresentation ( itr->movable->getName() );

              if ( Encloser != NULL )
                {
                  cout << "position camera " << mCamera->getPosition() << endl;
                  Ogre::Vector3 AVector ( mCamera->getPosition() - Encloser->getNode()->_getDerivedPosition());// mSceneMgr->getRootSceneNode()->convertLocalToWorldPosition ( Encloser->getNode()->getPosition() ) );
                  double localDistance = AVector.length();
                  cout << localDistance << endl;

                  if ( DistanceToCamera == -1 )
                    {
                      DistanceToCamera = localDistance;
                      temp = Encloser;
                    }
                  else
                    if ( ( DistanceToCamera >= localDistance ) )
                      {
                        DistanceToCamera = localDistance;
                        temp = Encloser;
                      }
                } 
            }
        }

      if ( SelectedDGtalNode != NULL )
        {
          SelectedDGtalNode->unselect();
        }

      if ( UpperFatherNonRoot != NULL )
        {
          UpperFatherNonRoot ->unselect();
        }


      if ( temp != NULL )
        {
          cout << "Retenu " << DistanceToCamera << endl;
          SelectedDGtalNode = temp->getAttachedParent();
          UpperFatherNonRoot = SelectedDGtalNode->getUpperNonRootNode();

          if ( SelectionMode )
            {
              mInputManager->stopRendering();
            }

          UpperFatherNonRoot ->groupSelect();

          SelectedDGtalNode->select();
        }
      else
        {
          SelectedDGtalNode = NULL;
          UpperFatherNonRoot = NULL;
        }


    }

    Representation  * ViewerOgre3D::addVoxel ( double x, double y, double z, Ogre::SceneNode * aNode )
    {

      Ogre::SceneNode * m_bodySceneNode = aNode->createChildSceneNode();
      Ogre::Entity  * m_ent = mSceneMgr->createEntity ( Ogre::SceneManager::PT_CUBE );
      m_ent->setMaterialName ( "Texture/Selected" );
      m_ent->setMaterialName ( "Texture/Unselected" );
      m_bodySceneNode->attachObject ( m_ent );
      m_bodySceneNode->setPosition ( Ogre::Vector3 ( x*40, y*40, z*40 ) );
      m_bodySceneNode->setScale ( 0.4, 0.4, 0.4 );
      DGtal::Representation * ARepresentation = new Representation ( mSceneMgr, m_ent, m_bodySceneNode, m_ent->getName() );
      return ARepresentation;

    }
  }





void ViewerOgre3D::addToList ( DGtalNode * aNode )
{
  myObjects[aNode->getName() ] = aNode;
}



Representation * ViewerOgre3D::findRepresentation ( std::string aName )
{


  std::map<std::string, DGtalNode *>::iterator aNode = myObjects.begin();

  Representation * theRepresentationToGet = NULL;

  while ( ( aNode != myObjects.end() ) && ( theRepresentationToGet == NULL ) )
    {


      theRepresentationToGet = ( *aNode ).second->getRepresentation ( aName );

      if ( theRepresentationToGet != NULL )
        {

        }
      else
        {
          aNode++;
        }
    }

  return ( theRepresentationToGet );


}



void ViewerOgre3D::ClearScene()
{
  mRootNode->clear();
  SelectedDGtalNode = NULL;
  UpperFatherNonRoot = NULL;
  myObjects.clear();
}

void ViewerOgre3D::sceneDisplay()
{
  mRootNode->display ( 0 );
}



void ViewerOgre3D::drawAxes()
{

  // Coordinate system Drawing
  myAxis =  mSceneMgr->createManualObject ( "Entity_Axis" );
  myAxisNode = mSceneMgr->getRootSceneNode()->createChildSceneNode ( "Node_Axis" );

  myAxis->begin ( "BaseWhiteNoLighting", Ogre::RenderOperation::OT_LINE_LIST );
  myAxis->position ( 0, 0, 0 );
  // Ex drawing
  myAxis->position ( 200, 0, 0 );
  myAxis->position ( 180, 0, 10 );
  myAxis->position ( 200, 0, 0 );
  myAxis->position ( 180, 0, -10 );
  myAxis->position ( 200, 0, 0 );

  //Ey Drawing
  myAxis->position ( 0, 0, 0 );
  myAxis->position ( 0, 200, 0 );
  myAxis->position ( 10, 180, 0 );
  myAxis->position ( 0, 200, 0 );
  myAxis->position ( -10, 180, 0 );
  myAxis->position ( 0, 200, 0 );

  //Ey Drawing
  myAxis->position ( 0, 0, 0 );
  myAxis->position ( 0, 0, 200 );
  myAxis->position ( 10, 0, 180 );
  myAxis->position ( 0, 0, 200 );
  myAxis->position ( -10, 0, 180 );
  myAxis->position ( 0, 0, 200 );
  myAxis->end();

  myAxisNode->attachObject ( myAxis );
}

void ViewerOgre3D::changeAxisVisibility()
{
  myAxisNode->flipVisibility();
}

void ViewerOgre3D::rotateWorld ( double x, double y )
{

  mCamera->lookAt(mySceneCenter);
  Ogre::Vector3 temp = mCamera->getOrientation().yAxis() * ( -y ) + mCamera->getOrientation().xAxis() *x;
    
    
 
  mCamera->setPosition(mCamera->getPosition() +temp);
  mCamera->lookAt(mySceneCenter);


/*
  mSceneMgr->getRootSceneNode()->setInitialState();
  mSceneMgr->getRootSceneNode()->rotate ( temp, Ogre::Degree ( 0.1 ), Ogre::Node::TS_PARENT );
  */
}

void ViewerOgre3D::translateWorld ( double x, double y )
{

  mCamera->setPosition ( mCamera->getPosition() - ( mCamera->getOrientation().yAxis() * ( -y ) + mCamera->getOrientation().xAxis() *x ) );
}


Ogre::Vector3 ViewerOgre3D::getLowerPosition()
{
  Ogre::Vector3 low=Ogre::Vector3(0,0,0);
  std::map<std::string,DGtalNode *>::iterator them=myObjects.begin();
  while(them!=myObjects.end())
  {
    if((low.z)>((*them).second->getNode()->getPosition().z))
    {
      low=(*them).second->getNode()->getPosition();
    }
          them ++;
  }
  return low;
}


Ogre::Vector3 ViewerOgre3D::getUpperPosition()
{
    Ogre::Vector3 up=Ogre::Vector3(0,0,0);
      std::map<std::string,DGtalNode *>::iterator them=myObjects.begin();
  while(them!=myObjects.end())
  {
    if((up.z)<((*them).second->getNode()->getPosition().z))
    {
      up=(*them).second->getNode()->getPosition();
      them ++;
    }
    them ++;
  }
  return up;
}